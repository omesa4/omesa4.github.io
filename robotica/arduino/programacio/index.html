<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programaci√≥ amb Arduino</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/js/all.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
        pre { background: #f4f4f4; padding: 10px; overflow-x: auto; position: relative; }
        code { font-family: monospace; }
        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
    </style>
    <script>
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.innerText;
            navigator.clipboard.writeText(codeBlock).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            });
        }
    </script>
</head>
<body>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python">  
  
// 02_01_blink

void setup() { // Codi que s'executa una vegada i √©s la configuraci√≥
  pinMode(13, OUTPUT); // Estem dient que el pin 13 √©s una sortida de corrent o OUTPUT on puc connectar un led
}

void loop() { // √âs un codi que s'executa sense parar fins que desconnecto l'Arduino o li dono una instrucci√≥ de parada
 digitalWrite(13, HIGH); // <b>digitalWrite</b>  √©s una sortida digital i permet encendre i apagar. Nom√©s t√±e 2 balors, HIGH i LOW (enc√®s i apagat)
 delay(500); // √âs el temps de millisegons en el que ha d'estar, en aquest cas enc√®s
 digitalWrite(13, LOW); // Aqu√≠ digitalWrite fa que s'apagui
 delay(500);
}

</code></pre>
    
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python">  
// Blink amb dos variables globals
// Avantatge: Quan canvio un n√∫mero al principi canviar√† tot el codi / S'enten millor perqu√® jo poso els noms de les variables
// Desavantatge: √©s una mica m√©s llarg
int ledPin = 13;
int delayPeriod = 500; // Declarem dos variables globals com a n√∫meros enters

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH); 
 delay(delayPeriod);
 digitalWrite(ledPin, LOW); // Utilitzo una variable global
 delay(delayPeriod); // Utilitzo una variable global
}
</code></pre>  

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python">  
// Codi blink amb un condicional

int ledPin = 13;
int delayPeriod = 100;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 delayPeriod = delayPeriod + 100; // Augmenta el temps 100 millisegons cada vegada
 if (delayPeriod == 1000) { // Quan arriba a 1000 millisegons torna a comen√ßar, aix√≤ significa que quan arriba als 1000 torna a comen√ßar perqu√® hem posat que delayPeriod sigui 100 de nou. 
  // Cada vegada √©s m√©s lent perqu√® el temps que triga en encendre i apagar-se √©s major (m√©s lent). Si volgues que cada vegada fos m√©s r√†pid, i s'hauria de canviar varies coses: al principi del codi canviar la variable de //int delayPeriod = 1000, i al final de codi posar el menys "delayPeriod -100", i finalment canviar el condicional per: if (delayPeriod == 100); delayPeriod = 1000;
  // Si volem que el canvi sigui m√©s lent s'hauria de posar un n√∫mero m√©s alt en "delayPeriod + x"
  // Si volem que el canvi sigui m√©s r√†pid s'hauria de posar un n√∫mero m√©s baix en "delayPeriod + x"
    delayPeriod = 100;
 }
}
</code></pre>
    
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python">  
// Operacions matem√†tiques (√ötils per sensors o per problemes matem√†tics)

void setup() {
  Serial.begin(9600); // Hem de connectar l'Arduino a la consola a√®rie a 9600 bauds, que s√≥n 9600 s√≠mbols per segon, I poden ser aproximadament 9600 bits per segon, per√≤, en alguns cassos, necessitem m√©s d'un bit per a un s√≠mbol
  int a = 2;
  int b = 2;
  int c = a + b; // Llenguatge arduino accepta les operacions matem√†tiques b√†siques
  Serial.println(c); 
}

void loop() {}
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python">  
// Exemple de temperatura amb operacions matem√†tiques

void setup() {
  Serial.begin(9600);
  int degC = 20; // Representa que el sensor ja ha agafat 20 graus i els volem convertir a Fahrenheit
  int degF;
  degF = degC * 9 / 5 + 32;
  Serial.println(degF); // Fes una impressi√≥ a la consola de l'ordinador en una l√≠nea println el valor de la variable fahrenheit
}

void loop(){}
</code></pre>

<p> El seguent codi podem veure com definim variables locals i les apliquem moltes vegades repetides dins del mateix codi (codi molt repetitiu)</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python">  
// Enc√©n i apaga manualment (amb instruccions) un led - Hard coded
//Variables globals, que s'utilitzaran moltes vegades repetides
    //Avantatges: Es pot canviar el periode i el nombre de pin al principi (variable global) i afecta a moltes linies
int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 
 delay(3000);
}
</code></pre>

<p> Amb el seg√ºent codi, aconseguim el mateix resultat de m√°s amunt, √©s a dir, encendre i apagar 20 vegades amb un delay de 250 millisegons, per√≤ no ho escribim 20 vegades, sin√≥ que fem un cicle for.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python"> 
// 02_08_blik_20_for

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  for (int i = 0; i < 20; i ++) { // Dins del circle for, tenim les condicions que ha de complir el cicle que s√≥n de i = 0 fins a i = 20, ves augmentant d'un en un. √©s a dor i++ que √©s el mateix que i = i + 1. Si volgu√©s podria canviar les condicions, fent que els n√∫meros augmentessin diferent (per exemple i = i + 5)
   digitalWrite(ledPin, HIGH);
   delay(delayPeriod);
   digitalWrite(ledPin, LOW);
   delay(delayPeriod);
  }
 delay(3000);
}
</code></pre>

<p> En el codi anterior, hem dit que es tepeteixi 20 vegades, per√≤ en quest es repeteix infinites vegades perqu√© es repeteix 20 vegades en un vaid loop. El seguent codi, posarem un contador i quan arribi a 20 repeticions s'aturar√†</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python"> 
// 02_09_blink_20_loop

int ledPin = 13;
int delayPeriod = 100;
int count = 0;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 count ++; // √©s una variable global que podria ser local, perqu√® nom√©s afecta al loop. Si escric "int count ++;" estaria definint una variable local dins del loop i no la podria utilitzar en cap altre funci√≥ que jo defineixi o al set up 
 if (count == 20) { // Quan el contador arriba a 20 deixa de fer parpadejos de 100 millisegons i fa una aturada de 3 segons abans de tornar a comen√ßar
   count = 0;
   delay(3000); 
 }
}
    // Dos iguals vol dir que √©s exactament igual, si possesim 3 iguals seria una comparaci√≥ estricta (no nom√©s compara el n√∫mero, tot tipus de variables). Si possem un igual, √©s una assignaci√≥, que pot ser temporal (temp) o constant (const)

<p> El seg√ºent codi √©s un exemple de creaci√≥ d'una funci√≥. Una funci√≥ √©s com un programa dins d'un programa</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python"> 
// 03_01_blink_function

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}
// Aquest codi √©s el principal, anomenat a "main" en alguns llenguatges. √âs el que s'aplica continuadament, en aquest cas void loop(). El loop repeteix 20 vegades el flash.Per cridar la funci√≥ nom√©s cal posar el nom de la funci√≥ dintre del loop per cridar-la i que s'executi sempre
void loop() {
  for (int i = 0; i < 20; i ++) {
    flash();
  }
 delay(3000);
}
// Per crear una funci√≥ nom√©s cal escriure el nom de la funci√≥ i uns par√©ntesis que poden ser buits o no. Si agu√©s alguna cosa entre par√©ntesis serien els par√°metres o arguments de la funci√≥ (en aquest cas no hi han). <b></b>Void</b> en aquest cas √©s equivalent a <b>function</b> de JavaScript. Triem un nom explicatiu de lo que fa la funci√≥, i dins les claus posem les linies de codi que s'han d'executar quan la cridem pel seu nom dins del void loop.
void flash() { 
   digitalWrite(ledPin, HIGH);
   delay(delayPeriod);
   digitalWrite(ledPin, LOW);
   delay(delayPeriod);
}
</code></pre>

<p> A continuaci√≥ veurem el codi flash per√≤ amb par√°metres</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python"> 
// 03_03_blink_functrion_params

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  flash(20, delayPeriod);
  delay(3000);
}
// Podem veure que la funci√≥ t√© dos par√°mentre que s√≥n dos nombres enters i que s'anomemen "nunFlashes" i "d". numFlashes no est√° definit com una variable global, √©s una variable local definida dins de la funci√≥ flash, i no t√© un valor predeterminat (nom√©s ha de ser un valor entre).
void flash(int numFlashes, int d) {
  for (int i = 0; i &lt; numFlashes; i ++) {
    digitalWrite(ledPin, HIGH);
    delay(d);
    digitalWrite(ledPin, LOW);
    delay(d);
  }
}
</code></pre>
<h2>Funcions en Arduino</h2>
<p> Els funcions de Arduino s√≥n semblants a les funcions que veiem a cinem√†tica directa i inversa. En el cas de cinem√†tica rob√≤tica utilitzem funcions JavaScript dins d'un codi html. Abans cada funci√≥ com per exemple, calculatePosition(); era una funci√≥ sense par√†metres o arguments que estava identificada amb un bloc de codi anomenat function, i s'executava quan clicavem un bot√≥. Dins d'aquest bloc hi havien instruccions que permetien fer c√†lculs matem√†tics. En el seguent codi d'Arduino tenim una funci√≥ flash amb dos par√†metres amb n√∫meros sencers, anomenat ledPin i de delayPeriod que identifiquen el pin que est√° connectat i el temps que ha d'estar enc√®s o apagat.</p>
<p> Ara farem que un bucle s'executi nom√©s 20 o x vegades dins d'un bucle for localitzat dins d'un bucle infinit loop. Ho aconseguin amb la paraula clau static, que fa que una variables'inicialitzi nom√©s una vegada que ser√° la primera vegada que correm el codi. La paraula static es deriva del llenguatge C i Arduino √©s un derivat de C++ i precessing. Si eliminem nom√©s la paraula static del codi seg√ºent s'executar√† infinites vegades. Aix√≠ aconseguim dins la funci√≥ loop controlar el n√∫mero de execucions, tamb√© ho podriem aplicar a altres funcions</p>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python"> 
// 03_04_blink_20_static

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  static int count = 0;
  digitalWrite(ledPin, HIGH);
  delay(delayPeriod);
  digitalWrite(ledPin, LOW);
  delay(delayPeriod);
  count ++;
  if (count == 20) {
    count = 0;
    delay(3000);
  }
}
</code></pre>

<h1>Arrays i strings</h1>
<p> Un array √©s una forma de contenir un llistat de valors, moltes vegades s√≥n valors enters i s'accedeix a ells per la seva posici√≥, sent la primeraposici√≥ [0] del array, o element 0</p>
<p> El codi seguent el que fa √©s, a la primera l√≠nea defineix un array amb diferents valors i els imprimeix al monitor s√®rie  els seus valors. Ser√† √∫til pel nostre codi morse.</p>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python"> 
int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  Serial.begin(9600);  
  for (int i = 0; i < 9; i++) {
    Serial.println(durations[i]);
  }
}

void loop() {}
</code></pre>

<p> El codi seguent ja √©s un codi morse, perqu√® combina un array, un bucle for (que llegeix l'array) i l'aplica a la funci√≥ flash, d'aquesta forma √©s com si escriv√≠s flash(200), flash(200), flash(200), flash(500), flash(500), flash(500), flash(200), flash(200), flash(200)</p> 
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-python"> 
const int ledPin = 13;

int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  for (int i = 0; i < 9; i++) {
    flash(durations[i]);
  }
  delay(1000);
}

void flash(int duration) {
   digitalWrite(ledPin, HIGH);
   delay(duration);
   digitalWrite(ledPin, LOW);
   delay(duration);
}
</code></pre>
    <p> Puc crear una funci√≥ que em serveixi per 4 lletres i nom√©s quan la crido he de possar el n√∫mero de repeticions com par√†metre o arguments</p>
    <pre><code>
    void eosz (int numFlash) {
        for (int i = 0; i <numFlashes; i ++){
            digitalWrite(ledPin, HIGH);
            delay (200);
            digitalWrite(ledPin, LOW);
            delay (200); }
    }
    void loop (){
        eosz(1); // Lletra e
        eosz(2); // Lletra o
        eosz(3); // Lletra s
        eosz(4); // Lletra z    
    </code></pre>

   // A continuaci√≥ creem una funci√≥ que ser√† v√†lida per als punts repetits i per les linies repetides amb dos par√†metres
    <pre><code>
    void eosz (int numFlash) {
        for (int i = 0; i <numFlashes; i ++){
            digitalWrite(ledPin, HIGH);
            delay (d);
            digitalWrite(ledPin, LOW);
            delay (d); }
    }
    void loop () {
            eosztmo(1, 600) // Lletra t
            eosztmo(2, 600) // Lletra m
    
    <h1> Normes internacionals del codi Morse</h1>
    <ol>
        <li> Una linea (dash) √©s igual a 3 punts (dots)</li>
        <li> L'espai entre les parts d'una mateixa lletra √©s d'un punt (dot)</li>
        <li> L'espai entre dues lletres d'una mat√®ixa paraula √©s de 3 punts</li>
        <li> L'espai entre dues paraules diferents √©s de 5 punts (dots)</li>
    </ol>
            <div class="content-container">
        <p>L'objectiu del codi seg√ºent √©s entendre que les cadenes o strings s√≥n conjunts de car√†cters ASCII i podem accedir 
            amb ells amb arrays que esta formats per par√®ntesis quadrats i el primer element √©s el 0. En llenguatge C i derivats
            del C com Arduino podem utilitzar punters o pointers que permeten apuntar a un element. En python o JavaScript no hi
            ha punters.</p>
            <p>A continuaci√≥ veuras els caracter ASCII en una taula, que son els utilitzats en els strings o cadenes</p>
            <p>La taula seg√ºent est√† basada en un codi binari de 7 bits, perque 2 elevat a 7 (2^7) es 128, hi hauran desde 0 a 
               127 car√†cters diferents</p>
        <table>
            <thead>
                <tr>
                    <th>ASCII</th>
                    <th>DECIMAL</th>
                    <th>BINARI</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>A-Z</td>
                    <td>65-90</td>
                    <td>1000001-1011010</td>
                </tr>
                <tr>
                    <td>a-z</td>
                    <td>97-122</td>
                    <td>1100001-1111010</td>
                </tr>
                <tr>
                    <td>0-9</td>
                    <td>48-57</td>
                    <td>110000-111001</td>
                </tr>
                <tr>
                    <td>espai</td>
                    <td>32</td>
                    <td>100000</td>
                </tr>
            </tbody>
            </th>
        </table>
        <p>ASCII significa American Standard Code for Information Interchange i va ser descrit a l'any 1967 amb l'objectiu 
            d'intercambiar informaci√≥ amb ordinadors</p>
        <p>UTF8 √©s un sistema Unicode Transformation Format que permet escriure m√©s d'un mili√≥ de car√†cters diferents
            ‚ÄúüôÇ‚Äù U+1F642</p>
                
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                // sketch 05-03

                char message[] = "Hello"; // Hi ha un array simbolitzat per "[]" que cont√© el car√†cter "char", Cada car√†cter d'ASCII te assignat un valor de 7 bits. Un valor de 7 bits va de 0 a 127 ja que 2^7 es 128. La "H" es 72, la "e" 101, etc... Per especificar el final de paraula posem un 0
                
                void setup() {
                  Serial.begin(9600);
                  message[0] = 'h';
                }
                
                void loop() {
                  Serial.println(message);
                  delay(1000);
                }
            </code></pre>

        </div>

 <h3> Import√†ncia dels punters + Exemple del codi Morse</h3>
 <p> Hi ha llenguatges amb punters i sense punters (amb: C i els seus derivats, com Arduino) o (sense: python o JavaScript)</p>
<p> El punter llegeix una adre√ßa a la mem√≥ria de l'ordinador, el contingut de l'adre√ßa dins de la mem√≥ria i la possici√≥ de l'adre√ßa en hexadecimal, tamb√© es pot manipular. Hi ha possicions de l'ade√ßa / mem√≥ria especial, com els sectors d'arrancada (aix√≠ es poden arreclar errors d'arrancada) </p>
<p> Els punters permeten per tenir un control total per part del programador de la mem√≥ria i els recursos de l'ordinador. El problema que t√© √©s que pot provocar errors a la mem√≥ria o accesos no permesos si no saps com fer funcionar el punter</p>
 <p> Els dos s√≠mbols per utilitzar punters s√≥n: l'asterisc '*', que serveix per veure el contingut de l'ader√ßa de mem√≥ria. I l'ampersand '&', que llegeix la posici√≥ de l'adre√ßa de mem√≥ria</p>
<p> La mem√≥ria d'un ordinador la podem imaginar com caixetes d'un array, on cada caixa t√© una direcci√≥ en hexadecimal que comen√ßa amb <b>0x</b> i un contingut de cadascuna d'aquestes caixa (que pot ser buit o pot contenir un valor) </p>

    <h4> Operacions avan√ßades amb punters</h4> 
        <ul>
            <li><b> Acc√©s directe a la mem√≥ria:</b> Permet modificar valors en posicions espec√≠fiques</li>
            <li><b> Manipulaci√≥ eficient d'arrays i strings (cadenes):</b> Un array √©s en ess√®ncia una llista d'ade√ßes amb principi i final amb punter al primer element</li>
           <li><b> Passar graus quantitats de dades a funcions:</b> En lloc de copiar valors, els punters passen la seva ader√ßa, estalviant mem√≥ria i temps. Aquest √©s un dels motius pels que C i derivats s√≥n m√©s r√†pids que python o JavaScript.</li>
            <li><b> Creaci√≥ d'estructures din√†miques:</b> Es pot crear coses com gr√†fics o lliestes enlla√ßades de forma f√†cil</li>
            <li><b> Interacci√≥ f√†cil amb microcontroladors:</b> Els microcontroladors utilitzen llengutges de baix nivell ja que √©s m√©s f√†cil de manipular (encara que s√≥n m√©s propers al hardware. Encara que, gr√†cies a l'augment de la mem√≥ria, s'ha pogut crear llenguatges com micropython o circutpython). </li>
        </ul>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// El principi del codi, abans de la funci√≥ de configuraci√≥ 'setup' i la funci√≥ principal 'loop' que s'executa continuament, hem d'escriure sempre variables o constants. A m√©s, al principi del codi trobem les constants i variables globals, anomenades aix√≠ perqu√® es poden cridar o executar des de qualsevol part del codi, a diferencia de les variables locals que es defineixen i utilitzen dins de la mateixa funci√≥ 'loop' o una funci√≥ addicional. Devant de les variables i constants globals hauriem d'afegiu les biblioteques necess√†ries per fer funcionar el nostre codi (amb '#include <nom_de_biblioteca.h>') l'extenci√≥ 'h' deriva de C y significa 'biblioteca de headers' o encap√ßalament.
const int ledPin = 13;
const int dotDelay = 200;
//'const' vol dir que la variable no es modificar√† dins del codi. 'int' o integer significa que el nombre que hagafem haur√† de ser enter, ja que els pins tenen n√∫meros enters. El pin 13 √©s especial, t√© una resist√®ncia interna en el cas d'Arduino uno permet connectar direcatment un led, perqu√® est√† al costat del pin GND i puc clavar o connectar un led directament sense cap circuit o placa. 'ledPin' √©s una variable constant i s'anomena aix√≠ per l'usuari , utilitzant camelCase i referint-nos  al que fa aquest pin.
char* letters[] = { // Aix√≤ √©s un array d'arrays (pointer*) perque dins de l'array letters hi han arrays m√©s petites formats per una combinaci√≥ de punts i ratlles (array filles), aix√≤ √©s un array de car√†cters -> √âs  un arrey o una matriu composada per diferents matrius
  ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",    // A-I
  ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.",  // J-R
  "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."          // S-Z
};
// M√©s amunt i m√©s abaix tinc dos arrays composats cadascun d'ells per arrays interns i cada array intern est√† composat de car√†cters que nom√©s poden ser punts o ratlles ('.' o '-').
//Quan jo crido 'letters[0]' el que obtinc √©s '.-' o sigui, la lletra A en codi Morse. Aquesta forma detreballar √©s molt dolenta des d'un punt de vista d'eficiencia, perqu√® estic utilitzant un byte (un conjunt de 8 bits) senser per cada punt o ratlla. Un bit √©s un valor de 0 o 1 i aix√≤ √©s podria utilitzar per fer els punts o les ratlles perqu√® els dos valors s√≥n dos estats (0 o 1) i el codi Morse tamb√© en t√© dos ('.' i '-') llabors podem substituir els car√†cters (asignar el 0 al punt i l'1 a la ratlla). 
// Quants bytes de mem√≥ria necessitarem utilitzant bytes o bits per codificar Morse?
// Aproximadament el Morse t√© (83 lletres + 26 n√∫meros) 109 punts o ratlles de car√†cters, de la manera m√©s eficient tindriem (109/8) 14 bytes i de la manera menys eficient (109 x 8) 872 bytes. Hem de tenir en compte
// En un byte hi han 8 bits diferent, iper aix√≤ es podrien fer 256 car√†cters diferents. De fer ASCII utilitza 7 bits per creat 128 car√†cters (de 0 a 127).
// L'asterisc '*' √©s molt impostant, ja que ens indica que √©s un punter, '[]'ens indica que √©s un array, 'numbers' m'indica el nom de l'array, i 'char' m'indica el tipus d'elements (car√†cters) que hi ha dins de l'array. L'array d'asota es diu numbers per√≤ est√† constituit per car√†cters, perqu√® tant els n√∫meros com com les lletres estan constituides per punts i ratlles que s√≥n car√†cters
char* numbers[] = { // En el cas concret del codi Morse, l'asterisc s'utilitza per especificar la mem√≥ria de cada lletra del codi Morse
  "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----."};

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
// En el setup o configuraci√≥ del microcontrolador indiquem que el pin 13 ara es diu "ledPin" sigui una sortida o "Output". Indiquem que l'Arduino que es comuniquiamb l'ordinador a trav√©s del port serial o s√®rie i comenci a una velocitat de 9600 bauds o s√≠mbols que s√≥n aproximadament 9600 bits / segon
}

void loop() {
// El loop √©s el codi principal, i el que el seu nom indica que es repeteix sense parar en un "loop". "char" significa que utilitzem una variable de tipus car√†cter i l'anomenem <b>ch</b>. "Serial.available" significa si est√† disponible la comunicaci√≥ s√®rie o un 'serial monitor' que comunica el microcontrolador aArduin amb el nostre dispositiu (ordinador)
// La comunicaci√≥ entre Arduino i l'ordinador √©s complexa:
// Primer pas: L'ordinador envia dades al monitor s√®rie a traves del USB per un mecanisme que s'anomena 'USB to Serial'
// Segon pas: La transfornaci√≥ anterior 'USB to Serial' ho fa un xip especial dins d'Arduino
// Tercer pas: Les dades en format s√®rie arriven a una part del microcontrolador anomenada 'UART' que significa Univeral Asynchronous Receiver Transmiter
// Quart pas: Envia les dades que rep a una mem√≥ria temporal o 'buffer' que pot emmagatzemar 128 bytes fins que s'elimina en el moment que es llegeix
// La funci√≥ serial available retorna el n√∫mero de bytes de dades en el 'buffer' que estan esperant per ser llegits. Si no hi ha cap missatge esperant a ser llegit, la funci√≥ retorna a 0
// La funci√≥ 'Serial.read' el que fa √©s llegir el primer o el seg√ºent car√†cter disponible i l'emmagatzema a la variable "ch"
// El s√≠mbol >= o <= s'utilitza per comparar amb el n√∫mero d'ASCII que correspon a la lletra 'a' per tant, podriem canviar l'a pel n√∫mero 97 i la z el n√∫mero 122. Els altres car√†cters que podem canviar serien 'A' (mayus) pel n√∫mero 65 i 'Z' (mayus) pel n√∫mero 90. El car√†cter '0' correspon al n√∫mero 48 i el car√†cter '9' correspon al 57. El car√†cter ' ' (espai en blanc) correspon al n√∫mero 32
// Els condicionals que hi ha dins del condicional general "Serial.available" el que fan √©s dir si es car√†cter √©s entre la a i la z, li restes el valor menys a. Imaginem que la lletra √©s una 'c', que equival al n√∫mero 99, llavors li restem la 'a' que √©s 97 quedaria el n√∫mero 2, que est√† dins d'un [] √©s a dir dins d'un array i correspondria al tercer element de l'array de les lletres. Aquest tercer element √©s "-.-."
// Un altre exemple 'H' estaria evaluat en un altre condicional (el de les maj√∫scules), aquest car√†cter equivilaria al n√∫mero 72 i li hem de restar 'A' que equival a 65, per tant ch- 'A' √©s 7, que √©s el vuit√© element de l'array de maj√∫scula [7] i letters[7] √©s "...."
// Per qu√® s'ha de restar? 
// Per con√®ixer la posici√≥ de la lletra a l'array, perqu√® he possat l'array ordenat des de la 'a'-'z' i des de la 'A'-'Z'
// Ara tenim el n√∫mero per exemple letters [7] igual a "...." i el que volem √©s aplicar una funci√≥. Aquesta funci√≥ √©s la funci√≥ "flashSequence" que agafar√† l'element vuit√© de l'array com arguments
    char ch;
  if (Serial.available() > 0) {
    ch = Serial.read();
    if (ch >= 'a' && ch <= 'z') {
      flashSequence(letters[ch - 'a']);
    }
    else if (ch >= 'A' && ch <= 'Z') {
      flashSequence(letters[ch - 'A']);
    }
    else if (ch >= '0' && ch <= '9') {
      flashSequence(numbers[ch - '0']);
    }
    else if (ch == ' ') {
      delay(dotDelay * 4);  // gap between words  
    }
  }
}
// El "void flashSequence()" √©s una funci√≥ que rep un argument, el que fa aquest argument √©s utilitzar un punter i seguir la seq√º√®ncia que es troba amb letters [7], que √©s "...." aquest quatre car√†cters o punts s√≥n una seq√º√®ncia de car√†cters ordenada gr√†cies al punter
// El codi seg√ºent el que fa √©s, amb la posici√≥ 'i' inicial de 0, que √©s el pointer* 'e' al principi de l'array "...." I el que fa √©s que, mentres aquests elements (while) de la seq√º√®ncia no sigui (!) = NULL, √©s a dir, mentres hi hagi un car√†cter, crida una funci√≥ diferent anomenada 'flashDotOrDash' que rep com a argument ell valor de 'i' concret en aquella seq√º√®ncia. Despr√©s de rebre'l pasa el seg√ºent valor de 'i', si la 'i' era el primer punt ".", la 'i++' primera o 'i = i+1' √©s el seg√≥n punt "." I aix√≠ fins al cinqu√® punt que s'atura tot, perqu√© es NULL (no hi ha 5√® punt).
void flashSequence(char* sequence) {
  int i = 0;
  while (sequence[i] != NULL) {
    flashDotOrDash(sequence[i]);
    i++;
  }
  delay(dotDelay * 3);    // gap between letters
// El delay serveix per deixar espai entre les lletres o seq√º√®ncies
}
// La funci√≥ "flashSequence ()" llegeix una determinada lletra que rep com a argument, letters [7] i reconeix que est√† formada per "...." i crida la funci√≥ "flashDotOrDash ()" fins que s'acaben els punts o ratlles i deixa un espai al final per indicar que √©s una lletra
// La funci√≥ "flashDotOrDash ()" t√© un par√†metre intern anomenat 'DotOrDash'. Aquesta funci√≥ sempre enc√®n un led, i el deixa enc√©s un temps esc√©s o delay. En cas de que sigui una ratlla , el fa 3 vegades m√©s llarg que un punt, gr√†cies a un condicional 'if' o en cas del contrari 'else'. No diem si √©s ratlla,  diem si no √©s punt
void flashDotOrDash(char dotOrDash) {
  digitalWrite(ledPin, HIGH);
  if (dotOrDash == '.') {
    delay(dotDelay);           
  }
  else { 
    // must be a dash 
    delay(dotDelay * 3);           
  }
  digitalWrite(ledPin, LOW);    
  delay(dotDelay); // gap between flashes
}
</code></pre>
// El loop √©s un bucle i cont√≠nuament va cridant la funci√≥ 'flashSequence ()' i el que fa √©s llegir cada lletra i convertirles en punts i ratlles, aquesta funci√≥ crida a la funci√≥ 'flashDotOrDash ()' continuament que fa que s'encengui els leds segon els punts i ratlles. Sempre hem de dividir el codi en diverses funcions, perimer per fer-lo m√©s modular i entendre que fa cada funci√≥ i a m√©s ens fa m√©s f√†cil el manteniment i canvis futurs.

<h2> Input i Output: Entrades i Sortides</h2>    
    <p> Les entrades i sortides poden ser de dues maneres diferents, digitals o anal√≥giques, les digitals poden ser de 0 volts o de 3.3 volts i en altres pl√†ques Arduino poden ser 0 i 5 volts. Les anal√≥giques srien graduals (0-3.3v) en 2^n passos, sent 'n' el n√∫mero de bits</p>
  <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int outPin = 3;
// pinMode √©s una funci√≥ predeterminada o 'built-in', vol dir que est√† predefinida en el llenguatge Arduino i sempre ha de rebre 2 arguments o par√†metres, el primer sempre ha de ser un n√∫mero enter o "int" (integer) que correspon al n√∫mero de pin que volem connectar (en aquest cas el 3), el segon argument √©s el mode que pot ser OUTPUT que significa sortida, o INPUT que significa entrada, tamb√© existeix INPUT_PULLUP. 
// Posarem un exemple per entendre millor el input 'pullup'. Tenim un ascensor que s'atura a l'inici i al final gr√†cies al 
// interriuptor de final de cursa (palanca que al arribar al final o principi fa). El pullup per definici√≥ fa que √©s
//connecti a una resistencia f√≠sica de entre 20 i 50kOhms que per defecte est√† en HIGH, al arribar al final de cursa
//es defineix el canvi a LOW. El cas 'pulldown' no existeix com a mode a Arduino, per√≤ si existeix el modo input 
// (faria el contrari, sempre obert i a l'arribar al final de carrera tancat) aquest mode no √©s ni pullup ni pulldown,
// √©s indetenminat, si connecto un cable a una entrada INPUT i el toco comen√ßar√© a donar senyals que variaran, √©s a dir
// per defecte va donant valors indeterminats. D'alguna forma l'INPUT √©s molt sensible a elements externs (canvis el√®ctrics)
// Si volem un comportament pullup sense escriure pullup hauriem d'utilitzar una resist√®ncia externa de 20 a 50 kOhms que 
// evitar√† valors indeterminats
// Perqu√® el pin 13 podria tenir un comportament inesperat o diferent amb el pullup?
// Ja que el pin 13 t√© una resist√®ncia interna incorporada, segurament d'un valor de 200 Ohm, suficient per a un led
      
void setup() {
  pinMode(outPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Enter 1 or 0");
}

void loop() {
  if (Serial.available() > 0) {
    char ch = Serial.read();
    if (ch == '1') {
      digitalWrite(outPin, HIGH);
    }
    else if (ch == '0') {
      digitalWrite(outPin, LOW);
    }
  }
}
  </code></pre>
      
// Quan tenim una entrada hem de possar mode input i en comptes de fer un digitalWrite que fem a les sortides
// hem de fer un digitalRead per obtenir l'entrada, que nom√©s pot ser un valor digital de 0 o 1 (binari)
// Si el voltatge √©s menor a 2,5 volts es traduir√† com un 0, en canvi si √©s superior com un 1
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int inputPin = 5;

void setup() {
  pinMode(inputPin, INPUT);
  Serial.begin(9600);
}

void loop() {
  int reading = digitalRead(inputPin);
  Serial.println(reading);
  delay(1000);
}
</code></pre>  

// El pullup estabilitza la senyal que rep per a que la transcripci√≥ a binari (0 i 1) sigui correcta. Si analitzem el que
// passa amb un oscil¬∑loscopi (mesura les oscil¬∑lacions de la corrent) si mirem un oscil¬∑loscopi unveurem que hi han 
// pujades i baixades quan premo el bot√≥ no baixa de forma ideal sin√≥ que t√© alguns pics que es diuen rebots 
// (bouncing / debouncing) en el cas de debouncing √©s m√©s correcte ja que el senyal per defecte √©s inestable i el que fem
// √©s estabilitzar-lo -> desrebotar.
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int inputPin = 5;

void setup() {
  pinMode(inputPin, INPUT_PULLUP);
  Serial.begin(9600);
}

void loop() {
  int reading = digitalRead(inputPin);
  Serial.println(reading);
  delay(1000);
}
</code></pre>
<p> Negaci√≥: el signe d'exclamaci√≥ "!" significa negar la variable que es posa despr√©s del signe</p>
// Hi ha dos variables inicials, que s√≥n constants per definici√≥ del codi. La variable ledPin √©s el pin el qual connectem el led, que √©s normalment el 13. I el pin 5 √©s un pin on connectem un interruptor per entrada de dades. El pin 5 est√† enc√©s per defecte perque li hem dit que 
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int inputPin = 5;
const int ledPin = 13;
int ledValue = LOW;

void setup()  {
  pinMode(inputPin, INPUT_PULLUP);
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
  }
}
</code></pre>
<p> Clica a la imatge per veure la simulaci√≥</p>
<a href ="https://www.tinkercad.com/things/00ca5XpFBJJ-circuit-54-monk" Target="_blank"> <img src = "54.png"> </a>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int inputPin = 5;
const int ledPin = 13;
int ledValue = LOW;

void setup()  {
  pinMode(inputPin, INPUT_PULLUP);
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
  }
}
</code></pre>
 <p> Soluci√≥ amb llibreria</p>
 <a href ="https://www.tinkercad.com/things/3eOSwW4E1xi-circuit-55-monk" Target="_blank"> <img src = "54.png"> </a>

<p> Soluci√≥ sense llibreria (simplement posant un delay de 500 millisegons) aconsegueix que el senyal que era inestable, despr√©s de 500 millisegons ja sigui estable, donant-li temps suficient.</p>        
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int inputPin = 5;
const int ledPin = 13;
int ledValue = LOW;

void setup()  {
  pinMode(inputPin, INPUT_PULLUP);
  pinMode(ledPin, OUTPUT);
}

void loop() {
  if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
     delay(500);
  }
}
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// El 'contact bounce' podriem traduir-ho com a rebot de contacte, √©s un problema com√∫ en diferents dispositius, com per exemple interruptors mec√†nics reles (interruptor que canvia la posici√≥ d'una palanca interna mitjan√ßant electromagnetisme), contactes de bateria. Tots aquests elements tenen en com√∫ que estan fets de metalls el√†stics, de forma que quan jo apreto un interruptor mec√†nic el metall que tanca el circuit rebota diverses vegades sobre el contacte, provocant una inestabilitat en el senyal
<img src="bouncy.png">
// Els moviments que veiem a dalt poden ser poc importants en un circuit de pot√®ncia que utilitza 220 volts a vegades no s'aprecien aquests canvis, per√≤ en un circuit de control que funciona amb un voltatge de 3.3 o 5 volts iq ue est√† dissenyat per entendrei resoldre senyals digitals i anal√≤giques pot provocar que entenguin les pujades i baixades com un flux de dades
// Com es pot evitar?  Ho podem evitar per software com veiem m√©s avall amb una biblioteca o per hardware, que vol dir, modificar f√≠sicament els elements per reduir el rebot. Per exemple, una superf√≠cie llisa de contacte seria millor perqu√® donaria menys rebots, si el metall fos menys el√†stic, rebotaria menys. Antigament els contactes dels interruptors en mullaven en mercuri, per evitar el rebot. Tamb√© es pot afegir un flitre com un condensador, per exemple que emmagatzemaria tots els excesos de c√†rrega produits.
#include <Bounce2.h> // Instal¬∑la i inclou la llibreria <a href="https://docs.arduino.cc/libraries/bounce2/">'Bounce2.h'</a> que √©s compatible amb totes les pl√†ques Arduino.

const int inputPin = 5; // Aquest valor √©s constant i correspon al interruptor
const int ledPin = 13; // Aquest valor √©s constant i correspon al led
int ledValue = LOW; // Aquest valor no √©s constant, per√≤ √©s un valor enter (integer), que per defecte, en aquest cas, t√© un valor inicial 0 (LOW)
Bounce bouncer = Bounce(); 
// La maj√∫scula de Bounce m'indica que √©s una classe, i al costat de la classe poso el nom de l'objecte que tindr√† totes les caracter√≠stiques de la classe anterior. Per exemple: Homo sapiens carla. Bounce(); escrit amb maj√∫scules √©s un m√®tode d'una classe que s'aplica a l'objecte bounce. Aquest sistema est√† basat en el llenguatge C++ perqu√® l'autor de la biblioteca ho ha descrit aix√≠
void setup() {
  pinMode(inputPin, INPUT_PULLUP);
  pinMode(ledPin, OUTPUT);
  bouncer.attach(inputPin); // La sintaxi del punt o dot syntax √©s molt important perqu√® apliquem un m√®tode o una funci√≥ deinida a la classe com a un objecte concret que √©s bouncer. Aquesta funci√≥ attach dep√®n nom√©s d'un argument o par√†metre que √©s inpunPin. Que far√† attach? L'attach lliga l'interruptor f√≠sic que est√† en inputPin a l'objecte bouncer que hem de controlar 
 // bouncer.interval(50); // interval in ms
}

void loop() {
  if (bouncer.update() && bouncer.read() == LOW) { // linia clau perqu√® est√† comprovant si ha conviat (bouncer.update retorna verdader o true si alguna cosa ha canviat a l'objecte bouncer) i la segona mart del codi comprova si a m√©s a m√©s '&&'comprova si el bot√≥ de l'interruptor est√† apagat perqu√® LOW = 0
   ledValue = ! ledValue; // Si est√† enc√©s, apagat, si est√† apagat, enc√©n
   digitalWrite(ledPin, ledValue);
  }
}
<h2> Sortides anal√≥giques</h2>
<p> Algunes sortides d'Arduino i altres microcontroladors s√≥n PMW (Pulse Width Modulation), es tracta d'una modulaci√≥ de l'ample dels pols. √âs a dir, es modula el temps que √©s 0 i que es 1, aconsegueix que en 0 s'apagui i que en 1 s'encengui. Nosaltres no observem que s'enc√©n i s'apaga, perqu√® √©s molt r√†pid el canvi i la nostra visi√≥ no ens permet veure-ho. Nosaltres veiem la llum en un percentatge que dep√©n del percentatge de temps que ha estat enc√©s la sortida, vol dir que en comples de donar 0 i 1, poden donar molts valors intermitjos</p> 
<img rsc= "PMWduty.jpeg">  
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600); // comen√ßa lo comunicaci√≥ s√®rie USB entre Arduino i l'ordinador a una velocitat de 9600 bauds (9600 s√≠mbols per segon). L'objecte Serial √©s de la classe serial i li apliquem amb la sintaxi del punt el m√®tode begin que t√© com a par√†metre o argument els un n√∫mero sencer que correspondr√† als bauds
  Serial.println("Enter Volts 0 to 5"); // demana a l'usuari que entri per la consola o per el serial monitor de l'Arduino IDE un n√∫mero entre 0 i 5. Println significa imprimeix una linea i li apliquem aen la sintaxis del punt a la classe serial pot rebre diversos par√†metres, si els posem entre comemtes s'escriuen tal qual i sin√≥, escriu el valor de la variable
}

void loop() { // codi rincipal que no s'atura mai, es repeteix fins que desconecto l'Arduino
  if (Serial.available() > 0) { // El m√®tode Serial.available espera car√†cters, major a 0 √©s que hi ha alg√∫n car√†cter
    float volts = Serial.parseFloat(); // parseFloat √©s una funci√≥ o m√®tode que s'aplica a l'objecte serial i la seva funci√≥ √©s parsejar o analitzar el contingut de car√†cters que arriba pel port serial i si √©s de tipus decimal o floating point number (n√∫mero amb coma flotant) o variable tipus float. Les variables tipus float inclouen les variable int o integer -> n√∫meros sencers. Tamb√© existeix parseInt que nom√©s acceptaria n√∫meros enters. El float volts crea un espai a la mem√≥ria de l'ordinador anomenat volts que haur√† de ser del tipus floating point number que emmagatzemar√† el que li arribi del port serial escrit per l'usuari. la variable volts emmagatzema el n√∫mero decimal que escriu l'usuari
    int pwmValue = volts * 255.0 / 5.0; // Els volts no ens serveixen perqu√® volem PWM perqu√® no velem valors entre 0 i 5, sin√≥ entre 0 i 255. Perqu√® entre 0 i 255? per que √©s el n√∫mero de bits (2^8 -> 256). Faig una regla de tres i multiplico el valor per 255 i divideixo entre 5. Per exemple si l'usuari inserta 2.5 tindras 2.5 * 255 / 5 = 127.5. Aquet valor es transformara en 127 perque ha de ser integer i es guardara en pwmValue.
    analogWrite(outputPin, pwmValue); // analogWrite √©s una funci√≥ predefinida al llengutge Arduino, derivada de C++ i 
    √©s tamb√© una biblioteca de processing. T√© dos arguments o par√†metres, el pin al que est√† connectat i el valor que
    volem escriure en el pin led (0-255), que far√† que el led s'encengui de forma proporcional als volts que l'usuari ha
    escrit. No t√© sentit utilitzar volts perqu√® s√≥n valors de 0 a 5 i no notaria el canvi d'intensitat del led que va de 0 a 255
  }
}

<p> El "const int outputPin" defineix el pin de sortida constant que no es pot canviar. Despr√©s de defiir el pin de sortida 3 i en output (sortida) i la velocitat bauds (9600), el codi demana que escriguim a la consola del programa Arduino IDE: Entre volts 0 - 5.</p>
<p> El loop principal comprova que hi hagi car√†cters escrits a la consola, despr√©s agafa el valor que hem donat i el guarda en la variable volts. El valor por ser en decimal perqu√® posa float ('Floating point number'). El m√®tode parseFloat l'apliquem amb la sintaxi del punt a l'objecte Serial (Que es posa en  maj√∫scula, normalment seria una classe en maj√∫scula) i agafa el valor de la consola en s√®rie. </p>
<p> La variable pwmValue √©s entra (int o 'integer') i el que fa √©s convertir el valor volts (0-5) a valors de 0 - 255, que √©s el n√∫mero de bits (2^14) tal i com indica el data sheet o fulla de caracter√≠stiques del ESP32S3. Si fos un ESP32S3 la l√≠nea de codi seria 
    "Serial.println("enter volts 0 - 3.3")"
    "int pmwValue = volts * 16384.0 / 3.3"</p>
<p> El ESP32S3 t√© l'avantatge de tenir m√©s resoluci√≥, √©s a dir, pot donar 16384 valors diferents entre 0 i 3.3 volts. Aix√≥ potser no es noti per un led, per√≤ es nota en un motor, on l'ESP32S3 permet accedir a m√©s velocitats diferents. Els motors poden arribar a 16 bits, que √©s 2^16 o 25536 valors diferents, que depenent del tipus de motor, pot ser observat o no.</p>
</code></pre>


<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int analogPin = 0; // El pin 0 en Arduino √©s el pin A0 (analog)

void setup() {
  Serial.begin(9600);
}

void loop() {
  int reading = analogRead(analogPin); // analogRead llegeix els valors analogics del analogPin de 0 a 1023
  float voltage = reading / 204.6; // 1023 / 5 = 204,6 Dividim 1023 (2^10 - 1 per a Arduino) entre 5 (volts d'Arduino)
                        // Ara ens interesa els volts perqu√® jo connecto un sensor por esemple de temperatura ( de 0 a 100
    graus, d'humitat 0% - 100%) i els valor de 0 a 1023 no tenen sentit, perqu√® si fos un altre ESP32 seria de 0 a 4095
    i el valor 500 en el primer cas estaria per la meitat i en el segon cas seria menys. Si utilitzem voltatge tenim una mesura
    real del que est√† passat en el sensor i buscarem la relaci√≥ entre els volts i la temperatura / humitat a la fulla de 
    caracter√≠stiques (datasheet), una vegada tenir la relaci√≥ farem una regla de 3 o un mapejat.
  Serial.print("Reading="); // Quan poso entre cometes el print em surt tal qual la paraula reading= que significa lectura
  Serial.print(reading); // reading no t√© cometes i √©s una variable que cont√© valors entre 0 i 1023
  Serial.print("\t\tVolts="); // \t deixa un espai de tabulador. 
  Serial.println(voltage); // Ens donar√† el valor en volts al costat de Volts=
    // Com quedar√† en el cas de reading 512?
    // Reading=512        Volts=2.5 // espera mig segon per der una altre lectura
    // Reading=256        Volts=1.25
  delay(500);
}

</code></pre>


<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

void setup() {
  Serial.begin(9600); // comen√ßa la comunicaci√≥ s√®rie USB entre Arduino i l'ordinador a una velocitat de 9600 bauds (9600 s√≠mbols per segon).
}

void loop() {
  int number = random(1, 7); // escull un n√∫mero enter aleatoriament del 1 el 7. (1, 7) √©s un interval aix√≠ que agafem el 1, 2, 3...7
    // Els n√∫meros aleatoris s√≥n importants per exemple en controls de qualitat perque  ens asegurem de tot no est√† decidit 
    per ning√∫
  Serial.println(number); // Perqu√® fem println i no fem print? perqu√® volem que surti una l√≠nea sobre una altre
  delay(500); // espera 500 millisegons
}
    
</code></pre>


<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(0)); // seed significa llavor i t√© com argument un n√∫mero, si per exemple poso randomSeed (4) 
    sempre em sortir√† la mateixa cadena de n√∫meros aleatoris.
}

void loop() {
  int number = random(1, 7);
  Serial.println(number);
  delay(500); 
}
</code></pre>
</body>
</html>
